generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                    String                @id @default(cuid())
  name                  String?
  email                 String?               @unique
  emailVerified         DateTime?
  image                 String?
  role                  Role                  @default(USER)
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  password              String?
  accounts              Account[]
  activities            Activity[]            @relation("AuthorActivities")
  attempts              Attempt[]
  contents              Content[]             @relation("AuthorContents")
  authoredNotifications Notification[]        @relation("AuthoredNotifications")
  placementTests        PlacementTestResult[]
  questions             Question[]            @relation("AuthorQuestions")
  recordings            Recording[]
  sessions              Session[]
  gradedSubs            Submission[]          @relation("SubmissionGrader")
  submissions           Submission[]          @relation("SubmissionOwner")
  userNotifications     UserNotification[]    @relation("UserNotifications")
  progress              UserProgress[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Topic {
  id          String    @id @default(cuid())
  slug        String    @unique
  title       String
  description String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  contents    Content[] @relation("TopicsOnContents")
}

model Tag {
  id        String    @id @default(cuid())
  name      String    @unique
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  contents  Content[] @relation("TagsOnContents")
}

model Module {
  id          String     @id @default(cuid())
  code        String     @unique
  type        ModuleType
  title       String
  description String?
  levelMin    CEFRLevel  @default(A1)
  levelMax    CEFRLevel  @default(C2)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  units       Unit[]

  @@index([type])
}

model Unit {
  id           String         @id @default(cuid())
  moduleId     String
  order        Int            @default(1)
  title        String
  overview     String?
  level        CEFRLevel
  skill        Skill
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  activities   Activity[]
  contents     Content[]
  module       Module         @relation(fields: [moduleId], references: [id], onDelete: Cascade)
  UserProgress UserProgress[]

  @@index([moduleId, order])
  @@index([skill, level])
}

model Content {
  id                  String             @id @default(cuid())
  unitId              String
  authorId            String?
  title               String
  summary             String?
  sourceUrl           String?
  level               CEFRLevel
  skill               Skill
  locale              String             @default("en")
  html                String?
  plainText           String?
  metadata            Json?
  createdAt           DateTime           @default(now())
  updatedAt           DateTime           @updatedAt
  grammarPointId      String?
  vocabEntryId        String?
  pronunciationItemId String?
  author              User?              @relation("AuthorContents", fields: [authorId], references: [id])
  GrammarPoint        GrammarPoint?      @relation(fields: [grammarPointId], references: [id])
  PronunciationItem   PronunciationItem? @relation(fields: [pronunciationItemId], references: [id])
  unit                Unit               @relation(fields: [unitId], references: [id], onDelete: Cascade)
  VocabEntry          VocabEntry?        @relation(fields: [vocabEntryId], references: [id])
  media               MediaAsset[]
  Question            Question[]
  tags                Tag[]              @relation("TagsOnContents")
  topics              Topic[]            @relation("TopicsOnContents")

  @@index([unitId])
  @@index([skill, level])
}

model MediaAsset {
  id         String     @id @default(cuid())
  contentId  String?
  url        String
  type       MediaType
  durationS  Int?
  mime       String?
  meta       Json?
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
  activityId String?
  Activity   Activity?  @relation(fields: [activityId], references: [id])
  content    Content?   @relation(fields: [contentId], references: [id])
  Question   Question[]
}

model Activity {
  id           String       @id @default(cuid())
  unitId       String
  authorId     String?
  type         ActivityType
  title        String
  instruction  String?
  maxScore     Int?
  timeLimitSec Int?
  level        CEFRLevel
  skill        Skill
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  author       User?        @relation("AuthorActivities", fields: [authorId], references: [id])
  unit         Unit         @relation(fields: [unitId], references: [id], onDelete: Cascade)
  attempts     Attempt[]
  media        MediaAsset[]
  questions    Question[]

  @@index([unitId, type])
  @@index([skill, level])
}

model Question {
  id          String             @id @default(cuid())
  activityId  String
  authorId    String?
  order       Int                @default(1)
  type        QuestionType
  prompt      String
  explanation String?
  score       Int                @default(1)
  data        Json?
  mediaId     String?
  contentId   String?
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  answers     AnswerKey[]
  submissions AnswerSubmission[]
  choices     Choice[]
  activity    Activity           @relation(fields: [activityId], references: [id], onDelete: Cascade)
  author      User?              @relation("AuthorQuestions", fields: [authorId], references: [id])
  content     Content?           @relation(fields: [contentId], references: [id])
  media       MediaAsset?        @relation(fields: [mediaId], references: [id])
  Submission  Submission[]

  @@index([activityId, order])
}

model Choice {
  id         String   @id @default(cuid())
  questionId String
  order      Int      @default(1)
  text       String
  value      String?
  isCorrect  Boolean  @default(false)
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@index([questionId, order])
}

model AnswerKey {
  id         String   @id @default(cuid())
  questionId String
  key        String
  meta       Json?
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@index([questionId])
}

model Attempt {
  id          String       @id @default(cuid())
  userId      String
  activityId  String
  startedAt   DateTime     @default(now())
  submittedAt DateTime?
  score       Int?
  status      String       @default("in_progress")
  meta        Json?
  activity    Activity     @relation(fields: [activityId], references: [id], onDelete: Cascade)
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  submissions Submission[]

  @@unique([userId, activityId, startedAt])
  @@index([userId, activityId])
}

model Submission {
  id               String             @id @default(cuid())
  attemptId        String
  userId           String
  questionId       String
  answerText       String?
  answerJson       Json?
  chosenIds        String[]
  isCorrect        Boolean?
  score            Int?
  feedback         String?
  gradedAt         DateTime?
  graderId         String?
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  AnswerSubmission AnswerSubmission[]
  recordings       Recording[]
  attempt          Attempt            @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  grader           User?              @relation("SubmissionGrader", fields: [graderId], references: [id])
  question         Question           @relation(fields: [questionId], references: [id], onDelete: Cascade)
  user             User               @relation("SubmissionOwner", fields: [userId], references: [id], onDelete: Cascade)

  @@index([attemptId, questionId])
}

model Recording {
  id           String     @id @default(cuid())
  submissionId String
  userId       String
  url          String
  durationS    Int?
  waveform     Json?
  meta         Json?
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  submission   Submission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([submissionId])
}

model GrammarPoint {
  id          String    @id @default(cuid())
  title       String
  level       CEFRLevel
  explanation String?
  patterns    String?
  examples    Json?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  contents    Content[]

  @@index([level])
}

model VocabEntry {
  id           String     @id @default(cuid())
  lemma        String
  pos          String?
  phonetic     String?
  level        CEFRLevel?
  definition   String?
  examples     Json?
  synonyms     String[]
  antonyms     String[]
  families     String[]
  collocations String[]
  idioms       String[]
  phrasalVerbs String[]
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  contents     Content[]

  @@index([lemma])
}

model PronunciationItem {
  id          String     @id @default(cuid())
  title       String
  level       CEFRLevel?
  description String?
  examples    Json?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  contents    Content[]
}

model UserProgress {
  id       String    @id @default(cuid())
  userId   String
  unitId   String
  status   String    @default("not_started")
  lastSeen DateTime?
  scoreSum Int?
  meta     Json?
  unit     Unit      @relation(fields: [unitId], references: [id], onDelete: Cascade)
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, unitId])
  @@index([status])
}

model AnswerSubmission {
  id           String     @id @default(cuid())
  questionId   String
  submissionId String
  data         Json
  question     Question   @relation(fields: [questionId], references: [id], onDelete: Cascade)
  submission   Submission @relation(fields: [submissionId], references: [id], onDelete: Cascade)

  @@index([questionId])
  @@index([submissionId])
}

model PasswordReset {
  id        String   @id @default(cuid())
  email     String
  otp       String
  expiresAt DateTime
  verified  Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([email])
  @@index([otp])
}

model Notification {
  id        String   @id @default(cuid())
  title     String
  message   String
  target    String
  authorId  String
  sentAt    DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  author    User     @relation("AuthoredNotifications", fields: [authorId], references: [id])

  @@index([authorId])
}

model UserNotification {
  id        String    @id @default(cuid())
  userId    String
  title     String
  message   String
  type      String    @default("info")
  link      String?
  sentBy    String
  read      Boolean   @default(false)
  readAt    DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  user      User      @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, read])
  @@index([sentBy])
}

model PlacementTestResult {
  id             String    @id @default(cuid())
  userId         String
  score          Int
  totalQuestions Int       @default(20)
  cefrLevel      String
  answers        Json
  startedAt      DateTime?
  completedAt    DateTime  @default(now())
  timeSpent      Int?
  skillScores    Json?
  correctAnswers Int?
  wrongAnswers   Int?
  skippedAnswers Int?      @default(0)
  metadata       Json?
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, completedAt])
  @@index([cefrLevel])
}

enum Role {
  USER
  ADMIN
}

enum CEFRLevel {
  A1
  A2
  B1
  B2
  C1
  C2
}

enum Skill {
  LISTENING
  READING
  WRITING
  SPEAKING
  GRAMMAR
  VOCABULARY
  PRONUNCIATION
  FUNCTIONAL_LANGUAGE
  MEDIATION
  ASSESSMENT
  CULTURE
}

enum ModuleType {
  LISTENING
  READING
  WRITING
  SPEAKING
  GRAMMAR_STRUCTURE
  VOCAB_LEXICAL
  PRONUNCIATION_PHONETICS
  FUNCTIONAL_COMMUNICATION
  MEDIATION_TRANSLATION
  TEST_REVIEW
  CULTURE_TOPICS_CONTENT
}

enum ActivityType {
  LECTURE
  LISTEN_FIND_ERROR
  LISTEN_DETAIL
  LISTEN_GIST
  READ_MAIN_IDEA
  READ_INFER
  READ_SKIMMING
  WRITE_SENTENCE
  WRITE_PARAGRAPH
  WRITE_EMAIL
  WRITE_SHORT_ESSAY
  SPEAK_TOPIC
  SPEAK_ROLE_PLAY
  SPEAK_DESCRIPTION
  GRAMMAR_FILL_BLANK
  GRAMMAR_TRANSFORMATION
  VOCAB_MATCHING
  VOCAB_CLZE
  PRONUN_MINIMAL_PAIR
  PRONUN_STRESS
  PRONUN_INTONATION
  FUNCTIONAL_DIALOG
  MEDIATION_SUMMARIZE
  MEDIATION_REPHRASE
  ASSESS_SECTION
}

enum QuestionType {
  SINGLE_CHOICE
  MULTI_CHOICE
  TRUE_FALSE
  SHORT_TEXT
  LONG_TEXT
  ORDERING
  MATCHING
  GAP_FILL
  AUDIO_RECORD
  FILE_UPLOAD
}

enum MediaType {
  AUDIO
  VIDEO
  IMAGE
  TEXT
  PDF
}
